#Examples for how to take a CircuitBreakerException and automatically turn it into an exception meaningful to the application you may be writing.

= Introduction =

Add your content here.


= Details =

The only “gotcha” is:  The mapped exception must be either a RuntimeException (or child) or must be declared as thrown by the intercepted method.  Otherwise, Java will throw an UndeclaredThrowableException at runtime.

Here’s what it took...  
Add the mapper declaration to the CircuitBreakerBean declaration:

{{{<constructor-arg>
     <bean class="net.applicaiton.device.service.AppCircuitBreakerExceptionMapper" />
</constructor-arg>}}}

... as in:

{{{<bean id="appCircuitBreaker" class="org.fishwife.jrugged.spring.CircuitBreakerBean">
     <constructor-arg>
          <bean class="net.applicaiton.device.service.AppCircuitBreakerExceptionMapper" />
     </constructor-arg>
     <property name="limit" value="3"/>
     <property name="windowMillis" value="5000"/>
     <property name="resetMillis" value="20000"/>
</bean>}}}

{{{//Implement a CircuitBreakerExceptionMapper
public class AppCircuitBreakerExceptionMapper implements CircuitBreakerExceptionMapper<AppCircuitBreakerException> {

    @Override
   public AppCircuitBreakerException map(CircuitBreaker breaker, CircuitBreakerException exception) {
        return new AppCircuitBreakerException(exception.getCause());
    }
}}}}

{{{/*
  * Use a runtime exception child to differentiate between the intercepted exception and the  
  * “thrown by circuitbreaker” exception (rather than mapping to what originally tripped the circuit).   
  * This is most useful when more than one external system is circuit-broken and you want to 
  * know which one threw.  I’m not sure how to handle method-level granularity.
  */
public class HossCircuitBreakerException extends RuntimeException {
    public HossCircuitBreakerException(Throwable cause) {
        super(cause);
    }
}}}}